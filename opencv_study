[OCL peopledetect study]
A. http://mccormickml.com/2013/05/09/hog-person-detector-tutorial/
B. cd ~/github/library/opencv-2.4.13.6/modules/ocl/src/opencl
vim objdetect_hog.cl
tabfind ../hog.cpp
tabfind ../../../objdetect/src/cascadedetect.cpp
tabfind ../../../core/include/opencv2/core/operations.hpp
tabfind ../../../objdetect/include/opencv2/objdetect/objdetect.hpp
tabfind ../../include/opencv2/ocl/ocl.hpp
tabfind ../../../../samples/ocl/peopledetect.cpp
C. 4 major kernels => compute_gradient : compute_hists : normalize_hists : classify_hists
   window : 64x128 so detector size = 7x15x4x9  
   group of block => 2x2 block 
   block: size=16x16, stride=8x8
   cell: size=12x12, stride=4x4 (i.e. (0,0), (0,4), (4,0), (4,4))
   per cell has 9 bins (0~180: 10:30:50:70:90:110:130:150:170)
   
   1) threhold in normalize    => elem = min(elem, threshold);
   2) threhold in classify     => labels[gidY * img_win_width + gidX] = (product + free_coef >= threshold);   
   3) threhold in group labels => groupRectangles(found_locations, group_threshold, 0.2);

   in smem allocation in compute_hists 
   group of block => block => bins => 4 cells => (width = 12)

   gaussian table from interp_weight
   cellx = 0, 1 => dist_x: (-4, 8),(-8, 4)
                   dist_center_x: (-8, 4),(-4, 8) => (0, 12),(4, 12)
   celly = 0, 1 => dist_y: (-4, 8),(-8, 4)
                   dist_center_y: (-8, 4),(-4, 8) => (0, 12),(4, 12)
D. there are 3 potential defects
   1) in compute_hists 
    const int dist_y_begin = -4 - 4 * lidY;
    for (int dist_y = dist_y_begin; dist_y < dist_y_begin + 12; ++dist_y)
    {
        float2 vote = (float2) (grad_ptr[0], grad_ptr[1]);
        QANGLE_TYPE2 bin = (QANGLE_TYPE2) (qangle_ptr[0], qangle_ptr[1]);

        grad_ptr += grad_quadstep; => shall be grad_quadstep*2
        qangle_ptr += qangle_step; => shall be qangle_step*2
   2) in compute hists 
        hist[bin.x * 48] += gaussian * interp_weight * vote.x;
        hist[bin.y * 48] += gaussian * interp_weight * vote.y;
      its better to use atomic increase ? 
   3) in classify_hists 
    if (tid < 32)
    {
        smem[tid] = product = product + smem[tid + 32];
        smem[tid] = product = product + smem[tid + 16];
        smem[tid] = product = product + smem[tid + 8];
        smem[tid] = product = product + smem[tid + 4];
        smem[tid] = product = product + smem[tid + 2];
    }
E. what performance optimzation 
   1) MERGE_GAUSSIAN_LUT: merge gaussian as one table for 2x2x12x12 = 576 but not 2x16x16 = 512 
      we can avoid one more multiple and to calculate dist_x, dist_y, dist_center_x, dist_center_y
   2) HISTOGRAM_SIMPLIFY_ALU: 
      use opencl vector type to speed up, for example float8 a, c; a.s01 = b * c.s01
   3) use private memory > local memory > private memory 
      but avoid register spilling 
   4) use texture/buffer to replace local memory transfer between kernels ?
      or avoid boundary data getting ? 
      const sampler_t _samplerImg = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_CLAMP | CLK_FILTER_NEAREST;
      CLK_ADDRESS_CLAMP: clamp to border color (i.e. 0,0,0 or 0,0,0,1) or CLK_ADDRESS_CLAMP_TO_EDGE 
   5) use one concat kernel by many kernel 
   6) use proper type or use large type to packed multiple data 
      ushort4 bin_tmp  = convert_ushort4(read_imageui(qangle, _samplerImg, (int2)((x>>1), y)));
      uchar8  bin_vec  = as_uchar8(bin_tmp);
   7) DETECT_ALL_LAYERS
      -use clFinish() ? reorder the flow ex: getPyramid ? and seperate all CPU and GPU tasks ?  
